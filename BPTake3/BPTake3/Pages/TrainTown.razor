@inject IJSRuntime JSRuntime
@inject NavigationManager navigationManager

@page "/StepTwo"

<h3>Puzzle Two</h3>

<p>This one's a little shorter as we just did a bunch of puzzles! </p>

<p>_his is not a drive by!<br />Just a shy guy looking for a two ply<br />Hefty bag won't hold myyyy love</p>

<p>With dr_ps of Jupiter in her ear</p>

<p>The _ay you move ain't fair you know<br />Hey Soul Sister</p>

<p>Followi_g the map that leads to you</p>

<p>Two words: _____ ____</p>

<p>When googling, please add "Los Angeles" to the search!</p>

<button class="btn btn-primary" @onclick="GetLocationAsync">Find your location async below</button>

@if (numberOfGuess > 0)
{
    <p>Latitude: @Latitude</p>
    <p>Longitude: @Longitude</p>
    <p>You are currently @Distance miles away from the target!</p>
}
@if (!string.IsNullOrEmpty(ErrorMessage))
{
    <p style="color:red">@ErrorMessage</p>
}

@if (LocationFound == false && numberOfGuess >= 5)
{
    <button class="btn btn-secondary" @onclick="() => LocationFound = !LocationFound">Things aren't cooperating? Click me to move on.</button>
}

@if (LocationFound)
{
    <p>You are close enough! Congrats!</p>

    // DUSTY: Change this for local testing
    <button class="btn btn-primary" @onclick='() => navigationManager.NavigateTo("StepThree")'>Click me once you have finished this location's activity!</button>
}


@code {
    PositionData Position { get; set; } = new PositionData();
    private string? Latitude { get; set; }
    private string? Longitude { get; set; }
    private double Distance { get; set; }
    private string? ErrorMessage { get; set; }
    public bool LocationFound { get; set; }
    public int numberOfGuess = 0;


    // DUSTY: UPDATED!
    private double TargetLatitude { get; set; } = 34.15401510005693;
    private double TargetLongitude { get; set; } = -118.3085300510556;


    private async Task GetLocationAsync()
    {
        Console.WriteLine("Button pressed!");
        numberOfGuess++;
        await JSRuntime.InvokeVoidAsync("geolocationInterop.getCurrentPosition", DotNetObjectReference.Create(this));
        Distance = CalculateDistance(Position.Latitude, Position.Longitude, TargetLatitude, TargetLongitude);

        if (Distance < 0.5) LocationFound = true;
    }

    [JSInvokable]
    public void ReceivePosition(PositionData position)
    {
        Latitude = position.Latitude.ToString();
        Longitude = position.Longitude.ToString();
        Position.Latitude = position.Latitude;
        Position.Longitude = position.Longitude;
        Console.WriteLine("Location grabbed");
    }

    [JSInvokable]
    public void ReceiveError(string message)
    {
        ErrorMessage = $"Error retrieving location: {message}";
        LocationFound = false;
    }

    public class PositionData
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }

    private double CalculateDistance(double lat1, double lon1, double lat2, double lon2)
    {
        const double R = 6371; // Radius of Earth in kilometers
        var dLat = ToRadians(lat2 - lat1);
        var dLon = ToRadians(lon2 - lon1);

        var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);

        var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
        return Math.Round(R * c * 0.621371, 2);
    }

    private double ToRadians(double deg) => deg * Math.PI / 180;
}

